Es muss sich für die Umstellung von Lamport-Timestamps zu Vektor-Uhren nicht viel verändern.
Zum Beispiel kann jeder Thread einen eigenen Zähler für empfangene und verarbeitete Nachrichten beibehalten,
welcher in einer Array-ähnlichen Datenstruktur mit einem dazugehörenden injektiven Index gespeichert wird.
Die Größe dieser Datenstruktur bestimmt sich durch die Anzahl der Threads. Zuletzt muss nur jeder Thread einen
Pointer auf diese Datenstruktur haben.


What kind of order would be implied by the vector clocks (total order/partial
order)?

Seien T0, T1, T2, T3 die Threads, die die Nachrichten verarbeiten sollen.
Seien V0, V1, V2, V3 die zu den Threads dazugehörigen Vektor-Uhren.
Sei T0 der Thread, der die erste externe Nachricht erhält
Simuliere unser Programm für nur eine Nachricht:
T0 erhält eine externe Nachricht --> V0 = [1,0,0,0]
T0 verschickt interne Nachricht an alle Threads:
T0 -> T0 --> V0 = [2,0,0,0]
T0 -> T1 --> V0 = [3,0,0,0], V1 = [3,1,0,0]
T0 -> T2 --> V0 = [4,0,0,0], V2 = [4,0,1,0]
T0 -> T3 --> V0 = [5,0,0,0], V3 = [5,0,0,1]

Es ergeben sich folgende Vektor-Uhren: V0 = [5,0,0,0], V1 = [3,1,0,0], V2 = [4,0,1,0], V3 = [5,0,0,1]
Diese haben keine totale Ordnung, da zB !(V1 <= V2) && !(V2 <= V1).
Das heißt im Allgemeinen implizieren die Vektor-Uhren eine partielle Ordnung.



Would the history of all threads be identical? If not, how would you test that
the exposed histories of the threads are
correct.

Wie man anhand des obigen Beispiels sehen kann, werden die Chroniken der Threads nicht identisch sein.
Man kann jedoch trotzdem feststellen, ob die Chroniken korrekt sind. Eine Chronik wäre nicht korrekt,
wenn zB. V0_i >= V0_j, mit i < j irgendwo auftauchen würde, wobei V0_i bzw. V0_j die Vektor-Uhren zum Zeitpunkt i bzw. j
beschreiben.  Dies könnte man testen, indem man zB. sich 2 Kopien der Chronik C1 und C2 macht und eine davon (o.b.d.A. C1)
sortiert. Dann entsteht C1_sort und man überprüft, ob C1_sort = C2. Wenn das nicht der Fall ist, dann ist die Chronik
nicht korrekt. Alternativ funktioniert auch Brute-Force, wenn auch langsamer.


What are the advantages/disadvantages of using Lamport Timestamps or
vector clocks?

Lamport:
+ totale Ordnung
+ Ein Thread bekommt die aktuelle logische Zeit, sobald er eine Nachricht erhält.
- Fehler lassen sich nicht gut zurückverfolgen, da die Lamport-Timestamps nicht Information über Sender oder Empfänger
  beinhalten
-

Vektoren:
+ Mithilfe einer Chronik lassen sich Fehler leichter zurückverfolgen, da man genau erkennen kann, ab wann, wo,
  welcher Thread was geschickt hat
+
- keine totale Ordnung
- bekommt nur die aktuelle logische Zeit, von nur einem Thread
